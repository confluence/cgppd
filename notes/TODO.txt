--------------------------------------------------------------------------------
RIGHT NOW
--------------------------------------------------------------------------------

REFACTORING / TESTS
    * current homemade logging sucks. Replace with google-glog.
    * check if everything in the threads is still threadsafe. Have we actually run the code with multiple threads?
    * check if the bonded component is growing weirdly when uim is flexible
    * check if graph deepcopy works -- unit test the molecule copy function in general
        * check that really soon, to make sure that the bonded potential isn't slowly growing because the geometric features in the graph are being duplicated, or something. That would be bad.
    * check if magnitude of bonded components is correct
        * actually, do we have any results for the bonded components from Kim?
        * could the tiny discrepancy from Kim's results be due to additional nonbonded components from inside segments? (There would be no inter-domain contribution because Kim & Hummer's model doesn't have a flex move).

    * Need to refactor bonded potential so that pairs within the same rigid domain are ignored. This avoids needless calculation and also LJ spikes from non-adjacent residues which are close together.
        * New plan:
            * One float stores segment_residue_ID.rigid_domain_ID; the other stores residue_ID.molecule_ID
            * Split them up with modff
            * for domain and molecule, only equality is important (and "not in a rigid domain" = zero)
            * if (i.domain == j.domain AND i.domain) OR (i.molecule == j.molecule AND (neighbours(i.segment_residue_id, j.segment_residue_id) OR neighbours(i.residue_id, j.residue_id))): do nothing
            * so:
                * pairs inside the same rigid domain are ignored
                * pairs in different molecules should always be calculated
                * pairs within the same molecule which are neighbours in the same segment are ignored
                * pairs within the same molecule which are neighbours in the whole molecule are ignored
            * PROBLEM: segment_residue_ID comparisons aren't valid unless we know the segment is the same.
            * Get around this by optionally calculating segment LJ/DH on the CPU? This is the default use case; we'd just set a flag to restore the current behaviour for the polymer tests.
            * FIX: construct a global segment_ID for all the flexible segments in a molecule (we check that these pairs are within a molecule). Gaps of, say, 10, between segments.
                * it is theoretically possible for a residue to be in two segments if they form a t-junction. (3 or more not possible?) In one direction, the residue will be adjacent to its segment neighbours on the backbone. Favour the other direction when constructing the id. Leave a gap in the other direction?
                * ANOTHER PROBLEM: residues connected across a non-adjacent bond are effectively adjacent, but this plan currently has no way to detect that. This can't be fixed by calculating the segment potential on the CPU; it's an issue with cross-domain potential.
            * TO DESIGN: how to determine what rigid domain a molecule is in
                * some kind of search through the graph, similar to the branch search
                * make a list of residues which are not in a flexible linker
                * start from the first residue; search the graph for neighbours along rigid paths; remove those residues from the list; add to first domain
                * take the next residue left in the list, etc.. until the list is empty

            * in the CUDA code, there is a check for pos.w < 0.0f instead of pos.w == PADDER_IDENTIFIER. Fix that. The segment value should always be positive, though.
            * E_TiledKernelNC was not updated with the new logic. Not detected because we're not testing it with a flexible molecule. Fix that in the replica test.

    * Why are the async sample times different? Different grouping? Why are the intervals irregular? This may be working as intended; will need to compensate in unit test.
    * valgrind is really upset about a lot of the stl container stuff.

    * clean up crappy Potential internals now that there are unit tests
    * unit test for parsing various input files (amino acids, torsions, etc..)
    * clean up output files as much as possible
        * put a separate ABOUT file with compilation options in the directory instead of appending suffixes and putting crap in the PDB files
        * stop outputting rotation / translation (no longer relevant)
            * but only if compiled with flexible linkers?
    * take out the initial replica potential calculation -- that's what unit tests are for.

SIMULATIONS
* diubiquitin simulations -- once the segment code is fixed
    * DON'T FORGET to make a fake side-chain out of alanine

THESIS
* write foundations chapter
* keep writing

--------------------------------------------------------------------------------
NOW
--------------------------------------------------------------------------------

MODEL CORRECTNESS
* potential is now much (?) bigger because of the bonded components -- that is likely to affect calculation of the bound state. Should it be this high? Are the units correct? Also including the potential from inside proteins should raise the total (right)?
    * analyse potential breakdown (from CPU-only version)
* Why is the LJ so huge for reference conformation 1 when internal potential is calculated? (assuming that two residues are really close together)
* Are any conversions required for the linker components?

CLEANUP / BUGFIX
* is it *actually* worth summing vector components separately? Probably not, and we don't do it everywhere anyway.
* remove unused code for e.g. old kernels and MC on the GPU
* use FLEXIBLE_LINKS flag in CUDA code; put back the old version if linkers are not enabled?
* fix chain processing
    * use chain names if they exist
    * fix old PDB files with chain id in the wrong place (WTF)
* remove printing of old cruft about translation/rotation
* 300k replica -- how is it found if there isn't one?!
* make sure all the non-crowders are actually loaded before all the crowders (don't rely on the input file to be correct)

--------------------------------------------------------------------------------
SOON
--------------------------------------------------------------------------------

OPTIMISATION
* why not precalculate the LJ coefficients which are independent from r?
    * We could definitely at least store Eij instead of eij.
    * How much extra storage / memory transfer overhead would be required for 3 coefficients (3EijSigij, 2Eij and 2^(1/6)Sigij)?
    * Maybe do it and test it? float3 table instead of float.

TEST
* stuff that's disabled
    * Kahan sums -- sort of tested; no difference apparent

OPTIONS
* add possibility to individually enable / disable all the MC mutations?
    * would be useful to disable whole-molecule translation / rotation for individual molecule tests
    * and to disable flex moves if rigid domains should be static relative to each other

VALIDATION
* should we try crankshaft moves with more residues, and see if this improves the repulsive LJ results?

REFACTOR
* is it really necessary to use custom vector3f and vector3d types?
* is it really necessary to use size_t for iterators instead of int?
* Reorder methods and attributes, especially in header.  SETUP, MC MOVES, POTENTIAL CALCULATION
* MOLECULE: constructor / destructor
    * reserveResidueSpace not consistently used?
* AMINO ACIDS
    * clean up read from file

SIMULATIONS
* redo Ian's tail/no tail simulations with flexible tail; replicate post-processing used in original thesis

BENCHMARKING
* do simulations with linkers give better results than rigid simulations? (What does "better" mean?)
* how much overhead is caused by the flexible linkers (on the CPU and on the GPU)?

--------------------------------------------------------------------------------
LATER / MAYBE
--------------------------------------------------------------------------------

CLEANUP
* Remove dependence on cutil, which is not supposed to be used in production.
    * Need timers and a way to check CUDA errors?
    * Possibly read the cutil source code and reimplement these?

OPTIMISE / TEST
* is caching of internal potential subtotals important? Probably still useful for CPU LJ/DH code.

ADD
* Multiple GPUs?  Does that work?  It should just work.
