--------------------------------------------------------------------------------
NOW
--------------------------------------------------------------------------------

* replace char[] with std:string for filenames, etc. Replace unnecessary char * with vectors.

* add all the processing / output stuff to simulation

* single rng for all replicas
* clean up CUDA a bit more (setting up and tearing down)

* extend unit test to a reasonably complete normal simulation (with reading of parameters, etc.)
* mock rng (?) for a predictable set of steps?

* figure out how data processing works
    * first PDB files are created; then they are postprocessed?
    * we will probably need the DCD thing for this; can't create a PDB file just from the translations and rotations anymore!
        * why DCD and not PDB? Existing tools for converting PDB to DCD? Yes! https://research.cchmc.org/wiki/index.php/Catdcd
    * So, add functionality for writing out PDB snapshot into the right format.
* get rid of the code duplication; put all the functionality in the same executable!

* we can output parameters for mutations, and replay them later to output PDBs? Or output regular snapshots of PDBs? Do we need a PDB for every mutation, to collect data?

* this fixes checkpointing for free

* start writing up

--------------------------------------------------------------------------------
THEN
--------------------------------------------------------------------------------

* make flex and crankshaft moves optional

* Linkers, etc. don't actually *need* to be arrays. Just keep them as vectors.
* clean up stuff for reading commandline params and reading args from file (look for examples of dispatch in c++, unless can find existing library).
* is it really necessary to use custom vector3f and vector3d types?
* is it really necessary to use size_t for iterators instead of int?

* Reorder methods and attributes, especially in header.  SETUP, MC MOVES, POTENTIAL CALCULATION

* MOLECULE: constructor / destructor
    * reserveResidueSpace not consistently used?
    * maybe use init from pdb function with rotation / translation params?
    * make Molecule::rotate call Molecule::setRotation, etc.?
* AMINO ACIDS
    * clean up read from file

MAKEFILE
* Use config for compilation options?
* Print out whether compiled with flexible linkers

--------------------------------------------------------------------------------
SOON
--------------------------------------------------------------------------------

WRITE
* Thesis skeleton
* Background chapter
    * Visualisation: graphs of LJ and DH potential vs residue distance (? -- for different types)
* Implementation

ADD
* Extra MC moves (just domain rotation?) on GPU?
* Make angle terms, crankshaft moves optional; test efficiency / accuracy of including them
* Make flexing optional; doesn't really work in cases with flexible loops coming out of domains.
* Validation with a simple test case
* Is the caching stuff actually a good idea, or is it just overhead?
    * Write another version of the CPU bond calculation, which throws out the caching and calculates everything
* What happens if molecule consists of multiple chains?

TEST
Potential:
* test data
* !!! check performance of CPU NC E with doubles / floats
* unit test for kahan sums, repulsive crowding

TEST
* write an end-to-end test for optimisation comparisons
    * is component-wise addition of vectors important?
    * is caching of internal potential subtotals important?

--------------------------------------------------------------------------------
LATER
--------------------------------------------------------------------------------

* Nice examples to go in paper

--------------------------------------------------------------------------------
EVENTUALLY
--------------------------------------------------------------------------------

OPTIMISE

* is it *actually* worth summing vector components separately?

* init of gpu memory seems slower (underlying software change?)

* Now that there's more time, try doing stuff on GPU:
    * one molecule only (since only one molecule will have internal changes?)
    * but then we have to cache at the molecule level at least, so that potential comparison works
    * LJ/DH seems like a really good idea
    * single kernel based on segments, or aditional kernel just for internal segments?
    * Friedrichs, et al.have a kernel for bonded forces

ADD
* Multiple GPUs?  Does that work?
