



--------------------------------------------------------------------------------
NOW
--------------------------------------------------------------------------------

* Why is GL preview broken for polyalanine? Try to fix this by Monday before the demo.
    * probably the boundary; sample diubuquitin with flexible tails is fine.

* linker validation tests:
    * polyalanine with increasing polymer length (using single replica at first; will see how it goes)
    * are the large molecule tests not running for long enough, or has the rejection problem resurfaced? 512 is not very compact.
    * there's a suspicious cliff
    * run 2048 with same parameters for completeness
    * try re-running large molecules for longer -- DONE; results inconclusive
    * try re-running them with a bigger boundary
    * how feasible would it be to run simulations until the length / radius converges? Test whenever samples are taken? Will need to specify exchange frequency rather than number of exchanges.
    * PROBLEM: 2048 PDBs have a float size problem. This probably means that the length and radius are wrong.
        * Partial solution: calculate radius and length at sample time (make it optional) and prefer that data.
        * Programmatic generation of polyalanine? Can we reverse-engineer it from the generated PDBs?

* Write unit tests for all the mutations. Seriously, we need those.

* Refactor all the wrapping stuff, because it's terrible
    * Split two boundary types
        * at the start, calculate new center and reject the move if boundary is spherical and center is too large
        * then do everything
        * at the *end*, if the boundary is periodic, calculate the wrapped center and wrap the molecule if necessary
            * but this can still result in residues being moved twice in e.g. flex move
            * does that really matter?
            * Make an effort always to update the relative position and then the absolute position -- eliminate recalculate_relative_positions
            * If we do that, moving twice for wrapping won't be a problem -- just calculate the absolute position once after wrapping!

* check if compensated summation explains the discrepancy between the reference conformation values in the thesis and the implementation.

* fix chain processing
* remove printing of old cruft about translation/rotation

* 300k replica -- how is it found if there isn't one?!
* paircount needs to be updated for flexible linkers

* start writing up
    * skeleton
    * design / implementation of changes chapter

--------------------------------------------------------------------------------
MAIL ROB
--------------------------------------------------------------------------------

* Units! Where do they come from? Are any conversions required for the linker components?
* Is the flex move actually a valid extension of the model? Does the polymer test demonstrate that?
* Should we include the last *two* rigid residues when calculating the torsion? There's still one degree of freedom. Keep the way it is for now; ask Rob.


--------------------------------------------------------------------------------
SOON
--------------------------------------------------------------------------------

TEST

* stuff that's disabled, e.g. Kahan sums

POSTPROCESS

* write it completely separately in Python

OPTIONS

* make flex and crankshaft moves optional

REFACTOR

* Linkers, etc. don't actually *need* to be arrays. Just keep them as vectors.
* is it really necessary to use custom vector3f and vector3d types?
* is it really necessary to use size_t for iterators instead of int?

* Reorder methods and attributes, especially in header.  SETUP, MC MOVES, POTENTIAL CALCULATION

* MOLECULE: constructor / destructor
    * reserveResidueSpace not consistently used?
    * maybe use init from pdb function with rotation / translation params?
    * make Molecule::rotate call Molecule::setRotation, etc.?
* AMINO ACIDS
    * clean up read from file

--------------------------------------------------------------------------------
LATER / MAYBE
--------------------------------------------------------------------------------

TWISTER

* make sure all the non-crowders are actually loaded before all the crowders (don't rely on the input file to be correct)
* single rng for all replicas
    * CAUTION: this may be a problem because of threading (safety and/or performance). Look into it in greater detail.

ADD

* Extra MC moves (just domain rotation?) on GPU?
* Make angle terms, crankshaft moves optional; test efficiency / accuracy of including them
* Make flexing optional; doesn't really work in cases with flexible loops coming out of domains.
* Validation with a simple test case
* Is the caching stuff actually a good idea, or is it just overhead?
    * Write another version of the CPU bond calculation, which throws out the caching and calculates everything
* What happens if molecule consists of multiple chains?

CHECKPOINTING

* put checkpointing back in
    * save individual pdb files
    * save checkpointing file with list of pdb files to load and iteration count
    * when resuming, make sure the iteration count is increased and e.g. sampling starts immediately if it needs to
    * save/load:
        * parameters.currentStep
        * per-replica cumulative data (same stuff that is swapped during replica exchange)
        * per-simulation cumulative data (total tests and exchanges)

OPTIMISE / TEST

* is caching of internal potential subtotals important?
* is it *actually* worth summing vector components separately?
* init of gpu memory seems slower (underlying software change?)

ADD

* Multiple GPUs?  Does that work?
