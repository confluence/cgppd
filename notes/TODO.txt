--------------------------------------------------------------------------------
NOW
--------------------------------------------------------------------------------

CLEANUP
* REMOVE WRAPPERS; put molecule stuff in Molecule
* put initRNGs, etc. in init
* log function with loglevels which does cout conditionally; replace million OUTPUT_LEVEL checks?
* delete Molecule::rotate
* make Molecule::rotateQ call Molecule::setRotation, etc.
* move definitions of MC move constants to definitions and rename them
* reserveResidueSpace not consistently used; use or remove
* remove filename.
* DELETE RESIDUES IN DESTRUCTOR; WTF!

ADD
* add helper functions to segment and molecule
* boundary conditions -- EVERYTHING, NOT JUST TRANSLATE?
* random selection of move
    * 1/4 chance of translation, rotation, flex, local (gsl_rng_uniform_int? make configurable somehow -- gsl_ran_discrete?)
    * configurable number of local (trans / crankshaft) moves -- default 3?
    * random choice of trans / crankshaft
* Make GPU MC call extra CPU moves for now?

FIX
* update simulation read / save to use DCD format

TEST
* write an end-to-end test for optimisation comparisons
    * is component-wise addition of vectors important?
    * is caching of internal potential subtotals important?

--------------------------------------------------------------------------------
SOON
--------------------------------------------------------------------------------
WRITE
* Thesis skeleton
* Poster
* Background chapter
* Implementation

CLEANUP
* Split up main.cpp into definitions, functions and just the main function, so that it can be unit tested.
* Eliminate duplication between constructors which take an existing object as a parameter, and copy methods
* delete cruft marked for deletion
* difference between nonCrowderResidues and nonCrowderCount?

ADD
* Extra MC moves (just domain rotation?) on GPU?
* Make angle terms, crankshaft moves optional; test efficiency / accuracy of including them
* Validation with a simple test case
* Is the caching stuff actually a good idea, or is it just overhead?
    * Write another version of the CPU bond calculation, which throws out the caching and calculates everything

TEST
Potential:
* test data
* !!! check performance of CPU NC E with doubles / floats
* unit test for kahan sums, repulsive crowding

--------------------------------------------------------------------------------
LATER
--------------------------------------------------------------------------------

* Nice examples to go in paper

--------------------------------------------------------------------------------
EVENTUALLY
--------------------------------------------------------------------------------

OPTIMISE

* consider reusing some of the ranges?

* is it *actually* worth summing vector components separately?

* init of gpu memory seems slower (underlying software change?)

* Now that there's more time, try doing stuff on GPU:
    * one molecule only (since only one molecule will have internal changes?)
    * but then we have to cache at the molecule level at least, so that potential comparison works
    * LJ/DH seems like a really good idea
    * Friedrichs, et al.have a kernel for bonded forces

CLEANUP
* Make CPU version compile -- now compiles, but not without CUDA libraries.  Need to fix makefile.

ADD
* Multiple GPUs?  Does that work?
